{
    "sourceFile": "Frontend/src/app/views/dashboard/dashboard.component.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1747820663333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1747820680624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -292,32 +292,8 @@\n       }\r\n     });\r\n   }\r\n \r\n-  private generateFiveCategorySentiment(index: number): number[] {\r\n-    let values: number[] = [0, 0, 0, 0, 0];\r\n-\r\n-    switch (index % 5) {\r\n-      case 0: // Very positive\r\n-        values = [5, 7, 13, 30, 45];\r\n-        break;\r\n-      case 1: // Very negative\r\n-        values = [42, 28, 15, 10, 5];\r\n-        break;\r\n-      case 2: // Slightly positive\r\n-        values = [8, 12, 20, 38, 22];\r\n-        break;\r\n-      case 3: // Slightly negative\r\n-        values = [25, 35, 20, 15, 5];\r\n-        break;\r\n-      case 4: // Neutral\r\n-        values = [12, 18, 40, 20, 10];\r\n-        break;\r\n-    }\r\n-\r\n-    return values;\r\n-  }\r\n-\r\n   showHistoryItemChart(prediction: any): void {\r\n     this.selectedHistoryItem = prediction;\r\n \r\n     // Update the current chart with this prediction's data\r\n"
                },
                {
                    "date": 1747820756871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,8 @@\n     RowDirective,\r\n     GutterDirective,\r\n     ColDirective,\r\n   ],\r\n-  changeDetection: ChangeDetectionStrategy.OnPush,\r\n })\r\n export class DashboardComponent implements OnInit {\r\n   private _cachedChartData: ChartData | null = null;\r\n   private _lastPredictionTimeStamp: Date | null = null;\r\n"
                },
                {
                    "date": 1747821080036,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -484,9 +484,45 @@\n     };\r\n   }\r\n \r\n \r\n-predictCsvFile\r\n+  predictCsvFile(): void {\r\n+    const file = this.fileUploadForm.get('csvFile')?.value;\r\n+\r\n+    if (!file) {\r\n+      alert('Please select a file first');\r\n+      return;\r\n+    }\r\n+\r\n+    // Upload file for prediction\r\n+    this.predictionService.uploadCsvForPrediction(file).subscribe({\r\n+      next: (response) => {\r\n+        if (!response) {\r\n+          // Handle null response\r\n+          alert('Failed to upload file. Please try again.');\r\n+          return;\r\n+        }\r\n+        \r\n+        // Add to pending files\r\n+        this.pendingFiles.push({\r\n+          id: response.fileId,\r\n+          name: response.name || file.name,\r\n+          timestamp: new Date(response.timestamp) || new Date()\r\n+        });\r\n+\r\n+        // Reset form\r\n+        this.fileUploadForm.reset();\r\n+\r\n+        // Start polling for status updates\r\n+        this.pollFileStatus(response.fileId);\r\n+      },\r\n+      error: (error) => {\r\n+        console.error('Error uploading file:', error);\r\n+        alert('Failed to upload file. Please try again.');\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n   loadFileToVisualization(fileId: string): void {\r\n     // Check if file already exists in visualization tabs\r\n     const existingFileIndex = this.csvFiles.findIndex(file => file.id === fileId);\r\n     \r\n"
                },
                {
                    "date": 1747821918083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,869 @@\n+import { ChangeDetectionStrategy, ChangeDetectorRef, Component, OnInit, signal, WritableSignal } from '@angular/core';\r\n+import { FormControl, FormGroup, ReactiveFormsModule, FormsModule } from '@angular/forms';\r\n+import { CommonModule, NgStyle } from '@angular/common';\r\n+import { DocsExampleComponent } from '@docs-components/public-api';\r\n+import {\r\n+  ButtonDirective,\r\n+  CardBodyComponent,\r\n+  CardComponent,\r\n+  CardHeaderComponent,\r\n+  ColComponent,\r\n+  ColDirective,\r\n+  FormControlDirective,\r\n+  FormDirective,\r\n+  FormLabelDirective,\r\n+  GutterDirective,\r\n+  ListGroupModule,\r\n+  ListGroupDirective, \r\n+  ListGroupItemDirective,\r\n+  NavComponent,\r\n+  NavItemComponent,\r\n+  NavLinkDirective,\r\n+  RowComponent,\r\n+  RowDirective,\r\n+  TableDirective,\r\n+  TextColorDirective,\r\n+  PaginationComponent,\r\n+  PageItemComponent,\r\n+  PageLinkDirective\r\n+} from '@coreui/angular';\r\n+import { ChartjsComponent } from '@coreui/angular-chartjs';\r\n+import { IChartProps } from './dashboard-charts-data'; \r\n+import { ChartData } from 'chart.js';\r\n+import { HttpClient, HttpClientModule } from '@angular/common/http';\r\n+import { ChartOptions } from 'chart.js';\r\n+import {   SAMPLE_PREDICTION_HISTORY,SAMPLE_CSV_FILES,SAMPLE_PENDING_FILES,SAMPLE_MY_FILES} from './datafiles';\r\n+import { PredictionService } from './prediction.service';\r\n+import { interval, Subscription, takeWhile } from 'rxjs';\r\n+\r\n+interface CsvFile {\r\n+  id: string;\r\n+  name: string;\r\n+  data: any[];\r\n+  chartData?: ChartData;\r\n+  isDefault?: boolean;\r\n+  status: string;\r\n+  timestamp: Date; \r\n+}\r\n+\r\n+@Component({\r\n+  selector: 'app-dashboard',\r\n+  templateUrl: 'dashboard.component.html',\r\n+  styleUrls: ['dashboard.component.scss'],\r\n+  imports: [\r\n+    CommonModule,\r\n+    PaginationComponent,\r\n+    PageItemComponent,\r\n+    PageLinkDirective,\r\n+    HttpClientModule,\r\n+    NavComponent,\r\n+    NavItemComponent,\r\n+    NavLinkDirective,\r\n+    TextColorDirective,\r\n+    CardComponent,\r\n+    CardBodyComponent,\r\n+    ReactiveFormsModule,\r\n+    ChartjsComponent,\r\n+    CardHeaderComponent,\r\n+    TableDirective,\r\n+    RowComponent,\r\n+    ColComponent,\r\n+    ListGroupDirective,\r\n+    ListGroupItemDirective,\r\n+    DocsExampleComponent,\r\n+    FormsModule,\r\n+    FormDirective,\r\n+    FormLabelDirective,\r\n+    FormControlDirective,\r\n+    ButtonDirective,\r\n+    NgStyle,\r\n+    RowDirective,\r\n+    GutterDirective,\r\n+    ColDirective,\r\n+  ],\r\n+})\r\n+export class DashboardComponent implements OnInit {\r\n+  private _cachedChartData: ChartData | null = null;\r\n+  private _lastPredictionTimeStamp: Date | null = null;\r\n+  private selectedHistoryItem: any = null;\r\n+  private statusCheckSubscription: Subscription | null = null;\r\n+\r\n+  public activeTab = 'single';\r\n+  public activeCsvFile = ''; // Track active CSV file\r\n+  public mainChart: IChartProps = { type: 'line' };\r\n+  public mainChartRef: WritableSignal<any> = signal(undefined);\r\n+  public chart: Array<IChartProps> = [];\r\n+  public fileSearchQuery: string = '';\r\n+  public filteredFiles: CsvFile[] = [];\r\n+  public pageSize: number = 10;\r\n+  public currentPage: number = 0;\r\n+  public Math = Math; // Make Math available to the template\r\n+  public isProcessingSinglePrediction: boolean = false;\r\n+  public historyPageSize: number = 5;\r\n+  public historyCurrentPage: number = 0;\r\n+  public selectedCategories: any[] = [];\r\n+  public showCategoryModal: boolean = false;\r\n+\r\n+  // Track the last prediction for chart display\r\n+  public lastSinglePrediction: {\r\n+    text: string;\r\n+    result: string; // The top prediction category\r\n+    confidence: number; // Confidence of top category\r\n+    categories: { name: string; value: number }[]; // All 5 categories with values\r\n+    timestamp: Date;\r\n+  } | null = null;\r\n+\r\n+  public singlePredictionHistory: {\r\n+    text: string;\r\n+    result: string;\r\n+    confidence: number;\r\n+    categories: { name: string; value: number }[];\r\n+    timestamp: Date;\r\n+  }[] = [];\r\n+\r\n+  // Pie chart options\r\n+  public pieChartOptions: ChartOptions = {\r\n+    maintainAspectRatio: false,\r\n+    plugins: {\r\n+      legend: {\r\n+        position: 'right',\r\n+      },\r\n+    },\r\n+  };\r\n+\r\n+  options = {\r\n+    maintainAspectRatio: false,\r\n+  };\r\n+\r\n+  // Add this inside your component class\r\n+  public pendingFiles: { id: string; name: string; timestamp: Date }[] = [];\r\n+  public myFiles: CsvFile[] = []; // This will store user's completed files\r\n+\r\n+  constructor(private http: HttpClient, private predictionService: PredictionService,  private cdr: ChangeDetectorRef) {}\r\n+\r\n+  get totalPages(): number {\r\n+    return this.currentCsvFile\r\n+      ? Math.ceil(this.currentCsvFile.data.length / this.pageSize)\r\n+      : 0;\r\n+  }\r\n+\r\n+  public singlePredictionForm = new FormGroup({\r\n+    textInput: new FormControl('', { nonNullable: true }),\r\n+  });\r\n+\r\n+  public fileUploadForm = new FormGroup({\r\n+    csvFile: new FormControl<File | null>(null),\r\n+    fileName: new FormControl(''),\r\n+  });\r\n+\r\n+  public csvFiles: CsvFile[] = [\r\n+    {\r\n+      id: 'csv1',\r\n+      name: 'Sample Data 1',\r\n+      isDefault: false,\r\n+      data: [\r\n+        { class: 'A', value1: 85, value2: 92 },\r\n+        { class: 'B', value1: 72, value2: 68 },\r\n+        { class: 'C', value1: 90, value2: 95 },\r\n+        { class: 'A', value1: 85, value2: 92 },\r\n+        { class: 'B', value1: 72, value2: 68 },\r\n+        { class: 'C', value1: 90, value2: 95 },\r\n+        { class: 'A', value1: 85, value2: 92 },\r\n+        { class: 'B', value1: 72, value2: 68 },\r\n+        { class: 'C', value1: 90, value2: 95 },\r\n+        { class: 'A', value1: 85, value2: 92 },\r\n+        { class: 'B', value1: 72, value2: 68 },\r\n+        { class: 'C', value1: 90, value2: 95 },\r\n+        { class: 'A', value1: 85, value2: 92 },\r\n+        { class: 'B', value1: 72, value2: 68 },\r\n+        { class: 'C', value1: 90, value2: 95 },\r\n+        { class: 'A', value1: 85, value2: 92 },\r\n+        { class: 'B', value1: 72, value2: 68 },\r\n+        { class: 'C', value1: 90, value2: 95 },\r\n+      ],\r\n+      status: 'completed',\r\n+      timestamp: new Date(),\r\n+      chartData: {\r\n+        labels: ['A', 'B', 'C'],\r\n+        datasets: [\r\n+          {\r\n+            label: 'Sample Dataset 1',\r\n+            backgroundColor: 'rgba(179,181,198,0.2)',\r\n+            borderColor: 'rgba(179,181,198,1)',\r\n+            pointBackgroundColor: 'rgba(179,181,198,1)',\r\n+            pointBorderColor: '#fff',\r\n+            pointHoverBackgroundColor: '#fff',\r\n+            pointHoverBorderColor: 'rgba(179,181,198,1)',\r\n+            data: [85, 72, 90],\r\n+          },\r\n+        ],\r\n+      },\r\n+    },\r\n+    {\r\n+      id: 'csv2',\r\n+      name: 'Sample Data 2',\r\n+      isDefault: false, // Added this property\r\n+      data: [\r\n+        { class: 'X', value1: 65, value2: 79 },\r\n+        { class: 'Y', value1: 88, value2: 91 },\r\n+        { class: 'Z', value1: 76, value2: 82 },\r\n+      ],\r\n+      status: 'completed',\r\n+      timestamp: new Date(),\r\n+      chartData: {\r\n+        labels: ['X', 'Y', 'Z'],\r\n+        datasets: [\r\n+          {\r\n+            label: 'Sample Dataset 2',\r\n+            backgroundColor: 'rgba(255,99,132,0.2)',\r\n+            borderColor: 'rgba(255,99,132,1)',\r\n+            pointBackgroundColor: 'rgba(255,99,132,1)',\r\n+            pointBorderColor: '#fff',\r\n+            pointHoverBackgroundColor: '#fff',\r\n+            pointHoverBorderColor: 'rgba(255,99,132,1)',\r\n+            data: [65, 88, 76],\r\n+          },\r\n+        ],\r\n+      },\r\n+    },\r\n+  ];\r\n+\r\n+  chartRadarData: ChartData = {\r\n+    labels: [\r\n+      'Eating',\r\n+      'Drinking',\r\n+      'Sleeping',\r\n+      'Designing',\r\n+      'Coding',\r\n+      'Cycling',\r\n+      'Running',\r\n+    ],\r\n+    datasets: [\r\n+      {\r\n+        label: '2020',\r\n+        backgroundColor: 'rgba(179,181,198,0.2)',\r\n+        borderColor: 'rgba(179,181,198,1)',\r\n+        pointBackgroundColor: 'rgba(179,181,198,1)',\r\n+        pointBorderColor: '#fff',\r\n+        pointHoverBackgroundColor: '#fff',\r\n+        pointHoverBorderColor: 'rgba(179,181,198,1)',\r\n+        data: [65, 59, 90, 81, 56, 55, 40],\r\n+      },\r\n+    ],\r\n+  };\r\n+\r\n+  ngOnInit(): void {\r\n+    this.predictionService.getUserData().subscribe({\r\n+      next: (userData) => {\r\n+        this.singlePredictionHistory = userData.predictionHistory;\r\n+        this.pendingFiles = userData.pendingFiles;\r\n+        this.myFiles = userData.completedFiles;\r\n+        this.filteredFiles = this.myFiles;\r\n+        \r\n+        // Set active CSV file if any exist\r\n+        if (this.csvFiles.length > 0) {\r\n+          this.activeCsvFile = this.csvFiles[0].id;\r\n+        }\r\n+        \r\n+        // Set initial data for single prediction display\r\n+        if (this.singlePredictionHistory.length > 0) {\r\n+          this.lastSinglePrediction = { ...this.singlePredictionHistory[0] };\r\n+          this.selectedHistoryItem = this.singlePredictionHistory[0];\r\n+        }\r\n+      },\r\n+      error: (error) => {\r\n+        console.error('Error loading user data:', error);\r\n+        // Fallback to sample data if API fails\r\n+        this.csvFiles = SAMPLE_CSV_FILES;\r\n+        this.singlePredictionHistory = SAMPLE_PREDICTION_HISTORY;\r\n+        this.pendingFiles = SAMPLE_PENDING_FILES;\r\n+        this.myFiles = SAMPLE_MY_FILES;\r\n+        this.filteredFiles = this.myFiles;\r\n+        \r\n+        if (this.singlePredictionHistory.length > 0) {\r\n+          this.lastSinglePrediction = { ...this.singlePredictionHistory[0] };\r\n+          this.selectedHistoryItem = this.singlePredictionHistory[0];\r\n+        }\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  showHistoryItemChart(prediction: any): void {\r\n+    this.selectedHistoryItem = prediction;\r\n+\r\n+    // Update the current chart with this prediction's data\r\n+    this.lastSinglePrediction = {\r\n+      text: prediction.text,\r\n+      result: prediction.result,\r\n+      confidence: prediction.confidence,\r\n+      categories: prediction.categories,\r\n+      timestamp: prediction.timestamp,\r\n+    };\r\n+\r\n+    // Clear the cache to force chart update\r\n+    this._cachedChartData = null;\r\n+  }\r\n+\r\n+  isSelectedHistoryItem(prediction: any): boolean {\r\n+    return (\r\n+      this.selectedHistoryItem &&\r\n+      this.selectedHistoryItem.timestamp === prediction.timestamp\r\n+    );\r\n+  }\r\n+\r\n+  filterFiles(): void {\r\n+    if (!this.fileSearchQuery) {\r\n+      this.filteredFiles = this.myFiles;\r\n+      return;\r\n+    }\r\n+\r\n+    const query = this.fileSearchQuery.toLowerCase();\r\n+    this.filteredFiles = this.myFiles.filter((file) =>\r\n+      file.name.toLowerCase().includes(query)\r\n+    );\r\n+  }\r\n+\r\n+  clearFileSearch(): void {\r\n+    this.fileSearchQuery = '';\r\n+    this.filterFiles();\r\n+  }\r\n+\r\n+  selectCsvFile(fileId: string): void {\r\n+    this.activeCsvFile = fileId;\r\n+    this.currentPage = 0;\r\n+  }\r\n+\r\n+  // Method to get current active CSV file data\r\n+  get currentCsvFile(): CsvFile | undefined {\r\n+    return this.csvFiles.find((file) => file.id === this.activeCsvFile);\r\n+  }\r\n+\r\n+  predictSingleText(): void {\r\n+    const textValue = this.singlePredictionForm.get('textInput')?.value;\r\n+    if (!textValue) return;\r\n+    this.isProcessingSinglePrediction = true;\r\n+\r\n+    this.predictionService.predictText(textValue).subscribe({\r\n+      next: (result) => {\r\n+        // Transform the API response to our internal format\r\n+        const categories = Object.entries(result.sentiment_scores)\r\n+          .map(([name, value]) => ({\r\n+            name: name === 'neutral' ? 'Neutral' : name, // Normalize 'neutral' to 'Neutral'\r\n+            value: Number((value as number * 100).toFixed(2)) // Convert to percentage and round\r\n+          }));\r\n+\r\n+        // Create prediction result\r\n+        const prediction = {\r\n+          text: textValue,\r\n+          result: result.final_prediction,\r\n+          confidence: Number((result.sentiment_scores[result.final_prediction] * 100).toFixed(2)),\r\n+          categories: categories,\r\n+          timestamp: new Date(),\r\n+          rawResponse: result // Keep raw response for reference if needed\r\n+        };\r\n+\r\n+        // Save prediction to history in the mock service\r\n+        this.predictionService.savePredictionToHistory(prediction);\r\n+\r\n+        // Update last prediction and add to history\r\n+        this.lastSinglePrediction = { ...prediction };\r\n+        this.singlePredictionHistory.unshift({ ...prediction });\r\n+\r\n+        // Select the new prediction\r\n+        this.selectedHistoryItem = this.singlePredictionHistory[0];\r\n+        this.historyCurrentPage = 0;\r\n+\r\n+        // Clear the cached chart data to force an update\r\n+        this._cachedChartData = null;\r\n+\r\n+        // Reset form and loading state\r\n+        this.singlePredictionForm.reset();\r\n+        this.isProcessingSinglePrediction = false;\r\n+      },\r\n+      error: (error) => {\r\n+        console.error('Error predicting text:', error);\r\n+        this.isProcessingSinglePrediction = false;\r\n+        // Handle error - perhaps show an error message to the user\r\n+        alert('Failed to process prediction. Please try again.');\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  getHeaders(dataRow: any): string[] {\r\n+    if (!dataRow) return [];\r\n+    return Object.keys(dataRow);\r\n+  }\r\n+\r\n+  /**\r\n+   * Removes a CSV file from the visualization\r\n+   * @param fileId The ID of the file to remove\r\n+   * @param event The click event (to prevent it from triggering the tab selection)\r\n+   */\r\n+  deleteCsvFile(fileId: string, event: Event): void {\r\n+    // Stop the event from propagating (to prevent tab selection)\r\n+    // Stop event propagation to prevent tab selection\r\n+    event.stopPropagation();\r\n+\r\n+    // Find and remove the file\r\n+    const index = this.csvFiles.findIndex((file) => file.id === fileId);\r\n+    if (index !== -1) {\r\n+      this.csvFiles.splice(index, 1);\r\n+\r\n+      // If we deleted the active file, select another one\r\n+      if (fileId === this.activeCsvFile && this.csvFiles.length > 0) {\r\n+        this.activeCsvFile = this.csvFiles[0].id;\r\n+      } else if (this.csvFiles.length === 0) {\r\n+        this.activeCsvFile = '';\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  // Method for file selection\r\n+  onFileSelected(event: Event): void {\r\n+    const fileInput = event.target as HTMLInputElement;\r\n+    const file = fileInput?.files?.[0];\r\n+    fileInput.value = ''; // Reset input so same file can be uploaded again\r\n+\r\n+    if (file) {\r\n+      this.fileUploadForm.patchValue({\r\n+        fileName: file.name,\r\n+        csvFile: file,\r\n+      });\r\n+    }\r\n+  }\r\n+\r\n+  // Basic CSV parser (you might want to use a library for more complex CSVs)\r\n+  parseCsvData(csv: string): any[] {\r\n+    const lines = csv.split('\\n');\r\n+    const headers = lines[0].split(',');\r\n+    const result: any[] = [];\r\n+\r\n+    for (let i = 1; i < lines.length; i++) {\r\n+      if (lines[i].trim() === '') continue;\r\n+\r\n+      const obj: any = {};\r\n+      const currentLine = lines[i].split(',');\r\n+\r\n+      for (let j = 0; j < headers.length; j++) {\r\n+        obj[headers[j].trim()] = currentLine[j]?.trim();\r\n+      }\r\n+\r\n+      result.push(obj);\r\n+    }\r\n+\r\n+    return result;\r\n+  }\r\n+\r\n+  // Generate chart data from CSV\r\n+  generateChartDataFromCsv(csvData: any[]): ChartData {\r\n+    // Simplified example\r\n+    const firstRow = csvData[0];\r\n+    if (!firstRow) return { labels: [], datasets: [] };\r\n+\r\n+    const keys = Object.keys(firstRow);\r\n+    const labels = keys.slice(1); // Assuming first column is label\r\n+\r\n+    return {\r\n+      labels,\r\n+      datasets: [\r\n+        {\r\n+          label: 'CSV Data',\r\n+          backgroundColor: 'rgba(75,192,192,0.2)',\r\n+          borderColor: 'rgba(75,192,192,1)',\r\n+          pointBackgroundColor: 'rgba(75,192,192,1)',\r\n+          pointBorderColor: '#fff',\r\n+          pointHoverBackgroundColor: '#fff',\r\n+          pointHoverBorderColor: 'rgba(75,192,192,1)',\r\n+          data: csvData.map((row) => parseFloat(row[keys[1]])),\r\n+        },\r\n+      ],\r\n+    };\r\n+  }\r\n+\r\n+\r\n+  predictCsvFile(): void {\r\n+    const file = this.fileUploadForm.get('csvFile')?.value;\r\n+\r\n+    if (!file) {\r\n+      alert('Please select a file first');\r\n+      return;\r\n+    }\r\n+\r\n+    // Upload file for prediction\r\n+    this.predictionService.uploadCsvForPrediction(file).subscribe({\r\n+      next: (response) => {\r\n+        if (!response) {\r\n+          // Handle null response\r\n+          alert('Failed to upload file. Please try again.');\r\n+          return;\r\n+        }\r\n+        \r\n+        // Check if file already exists in pending files to avoid duplication\r\n+        const existingPendingFileIndex = this.pendingFiles.findIndex(pf => pf.id === response.fileId);\r\n+        if (existingPendingFileIndex === -1) {\r\n+          // Only add to pending files if it's not already there\r\n+          this.pendingFiles.push({\r\n+            id: response.fileId,\r\n+            name: response.name || file.name,\r\n+            timestamp: new Date(response.timestamp) || new Date()\r\n+          });\r\n+        }\r\n+\r\n+        // Reset form\r\n+        this.fileUploadForm.reset();\r\n+\r\n+        // Start polling for status updates\r\n+        this.pollFileStatus(response.fileId);\r\n+      },\r\n+      error: (error) => {\r\n+        console.error('Error uploading file:', error);\r\n+        alert('Failed to upload file. Please try again.');\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  loadFileToVisualization(fileId: string): void {\r\n+    // Check if file already exists in visualization tabs\r\n+    const existingFileIndex = this.csvFiles.findIndex(file => file.id === fileId);\r\n+    \r\n+    if (existingFileIndex !== -1) {\r\n+      // File already exists in tabs, just activate it\r\n+      this.activeCsvFile = fileId;\r\n+      return;\r\n+    }\r\n+    \r\n+    // Otherwise, fetch file details from API\r\n+    this.predictionService.getFileDetails(fileId).subscribe({\r\n+      next: (fileDetails) => {\r\n+        // Create chart data from the file details\r\n+        const chartData = this.generateChartDataFromApiResponse(fileDetails);\r\n+        \r\n+        // Add to visualization tabs\r\n+        const newFile: CsvFile = {\r\n+          id: fileId,\r\n+          name: fileDetails.name,\r\n+          status: 'completed',\r\n+          timestamp: new Date(fileDetails.timestamp),\r\n+          isDefault: false,\r\n+          data: fileDetails.data || [],\r\n+          chartData: chartData\r\n+        };\r\n+        \r\n+        this.csvFiles.push(newFile);\r\n+        this.activeCsvFile = fileId;\r\n+      },\r\n+      error: (error) => {\r\n+        console.error('Error loading file details:', error);\r\n+        alert('Failed to load file details. Please try again.');\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  // Chart data for single prediction\r\n+  get singlePredictionChartData(): ChartData {\r\n+    if (!this.lastSinglePrediction) return { datasets: [] };\r\n+\r\n+    // Return cached data if prediction hasn't changed\r\n+    if (\r\n+      this._cachedChartData &&\r\n+      this._lastPredictionTimeStamp === this.lastSinglePrediction.timestamp\r\n+    ) {\r\n+      return this._cachedChartData;\r\n+    }\r\n+\r\n+    // Generate new chart data\r\n+    const chartData: ChartData = {\r\n+      labels: this.lastSinglePrediction.categories.map((c) => c.name),\r\n+      datasets: [\r\n+        {\r\n+          data: this.lastSinglePrediction.categories.map((c) => c.value),\r\n+          backgroundColor: [\r\n+            'rgba(255, 99, 132, 0.6)',\r\n+            'rgba(54, 162, 235, 0.6)',\r\n+            'rgba(255, 206, 86, 0.6)',\r\n+          ],\r\n+          borderWidth: 1,\r\n+        },\r\n+      ],\r\n+    };\r\n+\r\n+    // Cache the data and timestamp\r\n+    this._cachedChartData = chartData;\r\n+    this._lastPredictionTimeStamp = this.lastSinglePrediction.timestamp;\r\n+\r\n+    return chartData;\r\n+  }\r\n+\r\n+  getPaginatedData(\r\n+    dataArray: any[],\r\n+    currentPage: number,\r\n+    pageSize: number\r\n+  ): any[] {\r\n+    if (!dataArray || !dataArray.length) return [];\r\n+    const start = currentPage * pageSize;\r\n+    const end = start + pageSize;\r\n+    return dataArray.slice(start, end);\r\n+  }\r\n+\r\n+  // Common method to get visible page numbers\r\n+  getVisiblePageNumbers(\r\n+    totalItems: number,\r\n+    pageSize: number,\r\n+    currentPage: number\r\n+  ): number[] {\r\n+    const totalPages = Math.ceil(totalItems / pageSize);\r\n+    const pages: number[] = [];\r\n+\r\n+    if (totalPages <= 7) {\r\n+      // Show all pages if 7 or fewer\r\n+      for (let i = 0; i < totalPages; i++) {\r\n+        pages.push(i);\r\n+      }\r\n+    } else {\r\n+      // Show first, last, current, and pages around current\r\n+      pages.push(0); // First page\r\n+\r\n+      if (currentPage > 2) {\r\n+        pages.push(-1); // Ellipsis\r\n+      }\r\n+\r\n+      // Pages around current\r\n+      const start = Math.max(1, currentPage - 1);\r\n+      const end = Math.min(totalPages - 2, currentPage + 1);\r\n+\r\n+      for (let i = start; i <= end; i++) {\r\n+        pages.push(i);\r\n+      }\r\n+\r\n+      if (currentPage < totalPages - 3) {\r\n+        pages.push(-1); // Ellipsis\r\n+      }\r\n+\r\n+      if (totalPages > 1) {\r\n+        pages.push(totalPages - 1); // Last page\r\n+      }\r\n+    }\r\n+\r\n+    return pages;\r\n+  }\r\n+\r\n+  // Common method to change page\r\n+  changePage(page: number, target: 'bulk' | 'history'): void {\r\n+    if (target === 'bulk') {\r\n+      const totalPages = this.currentCsvFile\r\n+        ? Math.ceil(this.currentCsvFile.data.length / this.pageSize)\r\n+        : 0;\r\n+\r\n+      if (page >= 0 && page < totalPages) {\r\n+        this.currentPage = page;\r\n+      }\r\n+    } else {\r\n+      const totalPages = Math.ceil(\r\n+        this.singlePredictionHistory.length / this.historyPageSize\r\n+      );\r\n+\r\n+      if (page >= 0 && page < totalPages) {\r\n+        this.historyCurrentPage = page;\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  // Common method to handle page size changes\r\n+  onPageSizeChange(target: 'bulk' | 'history'): void {\r\n+    if (target === 'bulk') {\r\n+      this.currentPage = 0;\r\n+    } else {\r\n+      this.historyCurrentPage = 0;\r\n+    }\r\n+  }\r\n+\r\n+  formatCategoriesForTooltip(categories: any[]): string {\r\n+    if (!categories || !Array.isArray(categories)) return 'No categories';\r\n+    \r\n+    return categories\r\n+      .map(cat => `${cat.name}: ${cat.value}%`)\r\n+      .join('\\n');\r\n+  }\r\n+\r\n+  // Helper method to get color for category\r\n+  getCategoryColor(categoryName: string): string {\r\n+    const colorMap: Record<string, string> = {\r\n+      'Very Negative': 'rgba(220, 53, 69, 0.8)',\r\n+      'Slightly Negative': 'rgba(255, 193, 7, 0.8)',\r\n+      'Neutral': 'rgba(108, 117, 125, 0.8)',\r\n+      'Slightly Positive': 'rgba(13, 202, 240, 0.8)',\r\n+      'Very Positive': 'rgba(25, 135, 84, 0.8)'\r\n+    };\r\n+    \r\n+    return colorMap[categoryName] || 'gray';\r\n+  }\r\n+\r\n+  showCategoriesModal(categories: any[]): void {\r\n+    this.selectedCategories = categories;\r\n+    this.showCategoryModal = true;\r\n+    \r\n+    console.log('Categories:', categories);\r\n+    setTimeout(() => {\r\n+      this.showCategoryModal = false;\r\n+    }, 3000);\r\n+  }\r\n+\r\n+  pollFileStatus(fileId: string): void {\r\n+    // Clear any existing subscription for this file ID\r\n+    if (this.statusCheckSubscription) {\r\n+      this.statusCheckSubscription.unsubscribe();\r\n+      this.statusCheckSubscription = null;\r\n+    }\r\n+\r\n+    // Set up initial polling variable\r\n+    let completedOrError = false;\r\n+\r\n+    // Poll every 2 seconds\r\n+    this.statusCheckSubscription = interval(2000)\r\n+      .pipe(takeWhile(() => !completedOrError))\r\n+      .subscribe(() => {\r\n+        this.predictionService.checkFileStatus(fileId).subscribe({\r\n+          next: (status) => {\r\n+            if (status.status === 'completed') {\r\n+              // File is now completed\r\n+              completedOrError = true;\r\n+              \r\n+              // Remove from pending files\r\n+              this.pendingFiles = this.pendingFiles.filter(file => file.id !== fileId);\r\n+              \r\n+              // Refresh the files list to get the new completed file\r\n+              this.refreshFilesList();\r\n+              \r\n+              // Clean up the subscription\r\n+              if (this.statusCheckSubscription) {\r\n+                this.statusCheckSubscription.unsubscribe();\r\n+                this.statusCheckSubscription = null;\r\n+              }\r\n+            } else if (status.status === 'error') {\r\n+              // Handle error state\r\n+              completedOrError = true;\r\n+              this.pendingFiles = this.pendingFiles.filter(file => file.id !== fileId);\r\n+              alert(`Processing of file failed: ${fileId}`);\r\n+              \r\n+              // Clean up the subscription\r\n+              if (this.statusCheckSubscription) {\r\n+                this.statusCheckSubscription.unsubscribe();\r\n+                this.statusCheckSubscription = null;\r\n+              }\r\n+            }\r\n+            // For 'pending' status, we just keep polling\r\n+          },\r\n+          error: (error) => {\r\n+            console.error('Error checking file status:', error);\r\n+            completedOrError = true; // Stop polling on error\r\n+            \r\n+            // Clean up the subscription\r\n+            if (this.statusCheckSubscription) {\r\n+              this.statusCheckSubscription.unsubscribe();\r\n+              this.statusCheckSubscription = null;\r\n+            }\r\n+          }\r\n+        });\r\n+      });\r\n+  }\r\n+\r\n+  refreshFilesList(): void {\r\n+    this.predictionService.getFiles().subscribe({\r\n+      next: (response) => {\r\n+        if (!response) {\r\n+          console.error('Received null response from getFiles()');\r\n+          return;\r\n+        }\r\n+        \r\n+        // Update pending files - ensure we don't have duplicates\r\n+        const pendingFileIds = new Set(this.pendingFiles.map(file => file.id));\r\n+        \r\n+        // Only add files that aren't already in our pending list\r\n+        if (response.pendingFiles && Array.isArray(response.pendingFiles)) {\r\n+          response.pendingFiles.forEach(file => {\r\n+            if (!pendingFileIds.has(file.id)) {\r\n+              this.pendingFiles.push({\r\n+                id: file.id,\r\n+                name: file.name,\r\n+                timestamp: new Date(file.timestamp)\r\n+              });\r\n+            }\r\n+          });\r\n+          \r\n+          // Also ensure we remove any files that are no longer pending\r\n+          const apiPendingFileIds = new Set(response.pendingFiles.map((file: any) => file.id));\r\n+          this.pendingFiles = this.pendingFiles.filter(file => apiPendingFileIds.has(file.id));\r\n+        }\r\n+        \r\n+        // Update completed files\r\n+        if (response.completedFiles && Array.isArray(response.completedFiles)) {\r\n+          this.myFiles = response.completedFiles.map(file => ({\r\n+            id: file.id,\r\n+            name: file.name,\r\n+            status: 'completed',\r\n+            timestamp: new Date(file.timestamp),\r\n+            isDefault: false,\r\n+            data: [], // Empty initially, will be loaded when file is selected\r\n+            chartData: undefined // Will be generated when data is loaded\r\n+          }));\r\n+        }\r\n+        \r\n+        // Update filtered files\r\n+        this.filterFiles();\r\n+        \r\n+        // Trigger change detection to update the UI\r\n+        this.cdr.detectChanges();\r\n+      },\r\n+      error: (error) => {\r\n+        console.error('Error fetching files:', error);\r\n+        this.cdr.detectChanges();\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  generateChartDataFromApiResponse(fileDetails: any): ChartData {\r\n+    // Assuming the API returns data with sentiment categories and counts\r\n+    const sentimentCounts: Record<string, number> = {\r\n+      'Very Positive': 0, \r\n+      'Slightly Positive': 0, \r\n+      'Neutral': 0, \r\n+      'Slightly Negative': 0, \r\n+      'Very Negative': 0\r\n+    };\r\n+    \r\n+    // Count prediction categories\r\n+    if (fileDetails.data && Array.isArray(fileDetails.data)) {\r\n+      fileDetails.data.forEach((item: any) => {\r\n+        const prediction = item.Prediction;\r\n+        // Check if prediction exists and is a key in sentimentCounts\r\n+        if (prediction && Object.prototype.hasOwnProperty.call(sentimentCounts, prediction)) {\r\n+          sentimentCounts[prediction as keyof typeof sentimentCounts]++;\r\n+        }\r\n+      });\r\n+    }\r\n+    \r\n+    return {\r\n+      labels: Object.keys(sentimentCounts),\r\n+      datasets: [{\r\n+        label: 'Sentiment Distribution',\r\n+        backgroundColor: [\r\n+          'rgba(25, 135, 84, 0.8)',      // Very Positive - green\r\n+          'rgba(13, 202, 240, 0.8)',     // Slightly Positive - info blue\r\n+          'rgba(108, 117, 125, 0.8)',    // Neutral - gray\r\n+          'rgba(255, 193, 7, 0.8)',      // Slightly Negative - amber\r\n+          'rgba(220, 53, 69, 0.8)',      // Very Negative - red\r\n+        ],\r\n+        borderColor: 'rgba(179,181,198,1)',\r\n+        data: Object.values(sentimentCounts)\r\n+      }]\r\n+    };\r\n+  }\r\n+\r\n+\r\n+  ngOnDestroy(): void {\r\n+    if (this.statusCheckSubscription) {\r\n+      this.statusCheckSubscription.unsubscribe();\r\n+    }\r\n+  }\r\n+\r\n+}\r\n"
                }
            ],
            "date": 1747820663333,
            "name": "Commit-0",
            "content": "import { ChangeDetectionStrategy, ChangeDetectorRef, Component, OnInit, signal, WritableSignal } from '@angular/core';\r\nimport { FormControl, FormGroup, ReactiveFormsModule, FormsModule } from '@angular/forms';\r\nimport { CommonModule, NgStyle } from '@angular/common';\r\nimport { DocsExampleComponent } from '@docs-components/public-api';\r\nimport {\r\n  ButtonDirective,\r\n  CardBodyComponent,\r\n  CardComponent,\r\n  CardHeaderComponent,\r\n  ColComponent,\r\n  ColDirective,\r\n  FormControlDirective,\r\n  FormDirective,\r\n  FormLabelDirective,\r\n  GutterDirective,\r\n  ListGroupModule,\r\n  ListGroupDirective, \r\n  ListGroupItemDirective,\r\n  NavComponent,\r\n  NavItemComponent,\r\n  NavLinkDirective,\r\n  RowComponent,\r\n  RowDirective,\r\n  TableDirective,\r\n  TextColorDirective,\r\n  PaginationComponent,\r\n  PageItemComponent,\r\n  PageLinkDirective\r\n} from '@coreui/angular';\r\nimport { ChartjsComponent } from '@coreui/angular-chartjs';\r\nimport { IChartProps } from './dashboard-charts-data'; \r\nimport { ChartData } from 'chart.js';\r\nimport { HttpClient, HttpClientModule } from '@angular/common/http';\r\nimport { ChartOptions } from 'chart.js';\r\nimport {   SAMPLE_PREDICTION_HISTORY,SAMPLE_CSV_FILES,SAMPLE_PENDING_FILES,SAMPLE_MY_FILES} from './datafiles';\r\nimport { PredictionService } from './prediction.service';\r\nimport { interval, Subscription, takeWhile } from 'rxjs';\r\n\r\ninterface CsvFile {\r\n  id: string;\r\n  name: string;\r\n  data: any[];\r\n  chartData?: ChartData;\r\n  isDefault?: boolean;\r\n  status: string;\r\n  timestamp: Date; \r\n}\r\n\r\n@Component({\r\n  selector: 'app-dashboard',\r\n  templateUrl: 'dashboard.component.html',\r\n  styleUrls: ['dashboard.component.scss'],\r\n  imports: [\r\n    CommonModule,\r\n    PaginationComponent,\r\n    PageItemComponent,\r\n    PageLinkDirective,\r\n    HttpClientModule,\r\n    NavComponent,\r\n    NavItemComponent,\r\n    NavLinkDirective,\r\n    TextColorDirective,\r\n    CardComponent,\r\n    CardBodyComponent,\r\n    ReactiveFormsModule,\r\n    ChartjsComponent,\r\n    CardHeaderComponent,\r\n    TableDirective,\r\n    RowComponent,\r\n    ColComponent,\r\n    ListGroupDirective,\r\n    ListGroupItemDirective,\r\n    DocsExampleComponent,\r\n    FormsModule,\r\n    FormDirective,\r\n    FormLabelDirective,\r\n    FormControlDirective,\r\n    ButtonDirective,\r\n    NgStyle,\r\n    RowDirective,\r\n    GutterDirective,\r\n    ColDirective,\r\n  ],\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n})\r\nexport class DashboardComponent implements OnInit {\r\n  private _cachedChartData: ChartData | null = null;\r\n  private _lastPredictionTimeStamp: Date | null = null;\r\n  private selectedHistoryItem: any = null;\r\n  private statusCheckSubscription: Subscription | null = null;\r\n\r\n  public activeTab = 'single';\r\n  public activeCsvFile = ''; // Track active CSV file\r\n  public mainChart: IChartProps = { type: 'line' };\r\n  public mainChartRef: WritableSignal<any> = signal(undefined);\r\n  public chart: Array<IChartProps> = [];\r\n  public fileSearchQuery: string = '';\r\n  public filteredFiles: CsvFile[] = [];\r\n  public pageSize: number = 10;\r\n  public currentPage: number = 0;\r\n  public Math = Math; // Make Math available to the template\r\n  public isProcessingSinglePrediction: boolean = false;\r\n  public historyPageSize: number = 5;\r\n  public historyCurrentPage: number = 0;\r\n  public selectedCategories: any[] = [];\r\n  public showCategoryModal: boolean = false;\r\n\r\n  // Track the last prediction for chart display\r\n  public lastSinglePrediction: {\r\n    text: string;\r\n    result: string; // The top prediction category\r\n    confidence: number; // Confidence of top category\r\n    categories: { name: string; value: number }[]; // All 5 categories with values\r\n    timestamp: Date;\r\n  } | null = null;\r\n\r\n  public singlePredictionHistory: {\r\n    text: string;\r\n    result: string;\r\n    confidence: number;\r\n    categories: { name: string; value: number }[];\r\n    timestamp: Date;\r\n  }[] = [];\r\n\r\n  // Pie chart options\r\n  public pieChartOptions: ChartOptions = {\r\n    maintainAspectRatio: false,\r\n    plugins: {\r\n      legend: {\r\n        position: 'right',\r\n      },\r\n    },\r\n  };\r\n\r\n  options = {\r\n    maintainAspectRatio: false,\r\n  };\r\n\r\n  // Add this inside your component class\r\n  public pendingFiles: { id: string; name: string; timestamp: Date }[] = [];\r\n  public myFiles: CsvFile[] = []; // This will store user's completed files\r\n\r\n  constructor(private http: HttpClient, private predictionService: PredictionService,  private cdr: ChangeDetectorRef) {}\r\n\r\n  get totalPages(): number {\r\n    return this.currentCsvFile\r\n      ? Math.ceil(this.currentCsvFile.data.length / this.pageSize)\r\n      : 0;\r\n  }\r\n\r\n  public singlePredictionForm = new FormGroup({\r\n    textInput: new FormControl('', { nonNullable: true }),\r\n  });\r\n\r\n  public fileUploadForm = new FormGroup({\r\n    csvFile: new FormControl<File | null>(null),\r\n    fileName: new FormControl(''),\r\n  });\r\n\r\n  public csvFiles: CsvFile[] = [\r\n    {\r\n      id: 'csv1',\r\n      name: 'Sample Data 1',\r\n      isDefault: false,\r\n      data: [\r\n        { class: 'A', value1: 85, value2: 92 },\r\n        { class: 'B', value1: 72, value2: 68 },\r\n        { class: 'C', value1: 90, value2: 95 },\r\n        { class: 'A', value1: 85, value2: 92 },\r\n        { class: 'B', value1: 72, value2: 68 },\r\n        { class: 'C', value1: 90, value2: 95 },\r\n        { class: 'A', value1: 85, value2: 92 },\r\n        { class: 'B', value1: 72, value2: 68 },\r\n        { class: 'C', value1: 90, value2: 95 },\r\n        { class: 'A', value1: 85, value2: 92 },\r\n        { class: 'B', value1: 72, value2: 68 },\r\n        { class: 'C', value1: 90, value2: 95 },\r\n        { class: 'A', value1: 85, value2: 92 },\r\n        { class: 'B', value1: 72, value2: 68 },\r\n        { class: 'C', value1: 90, value2: 95 },\r\n        { class: 'A', value1: 85, value2: 92 },\r\n        { class: 'B', value1: 72, value2: 68 },\r\n        { class: 'C', value1: 90, value2: 95 },\r\n      ],\r\n      status: 'completed',\r\n      timestamp: new Date(),\r\n      chartData: {\r\n        labels: ['A', 'B', 'C'],\r\n        datasets: [\r\n          {\r\n            label: 'Sample Dataset 1',\r\n            backgroundColor: 'rgba(179,181,198,0.2)',\r\n            borderColor: 'rgba(179,181,198,1)',\r\n            pointBackgroundColor: 'rgba(179,181,198,1)',\r\n            pointBorderColor: '#fff',\r\n            pointHoverBackgroundColor: '#fff',\r\n            pointHoverBorderColor: 'rgba(179,181,198,1)',\r\n            data: [85, 72, 90],\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      id: 'csv2',\r\n      name: 'Sample Data 2',\r\n      isDefault: false, // Added this property\r\n      data: [\r\n        { class: 'X', value1: 65, value2: 79 },\r\n        { class: 'Y', value1: 88, value2: 91 },\r\n        { class: 'Z', value1: 76, value2: 82 },\r\n      ],\r\n      status: 'completed',\r\n      timestamp: new Date(),\r\n      chartData: {\r\n        labels: ['X', 'Y', 'Z'],\r\n        datasets: [\r\n          {\r\n            label: 'Sample Dataset 2',\r\n            backgroundColor: 'rgba(255,99,132,0.2)',\r\n            borderColor: 'rgba(255,99,132,1)',\r\n            pointBackgroundColor: 'rgba(255,99,132,1)',\r\n            pointBorderColor: '#fff',\r\n            pointHoverBackgroundColor: '#fff',\r\n            pointHoverBorderColor: 'rgba(255,99,132,1)',\r\n            data: [65, 88, 76],\r\n          },\r\n        ],\r\n      },\r\n    },\r\n  ];\r\n\r\n  chartRadarData: ChartData = {\r\n    labels: [\r\n      'Eating',\r\n      'Drinking',\r\n      'Sleeping',\r\n      'Designing',\r\n      'Coding',\r\n      'Cycling',\r\n      'Running',\r\n    ],\r\n    datasets: [\r\n      {\r\n        label: '2020',\r\n        backgroundColor: 'rgba(179,181,198,0.2)',\r\n        borderColor: 'rgba(179,181,198,1)',\r\n        pointBackgroundColor: 'rgba(179,181,198,1)',\r\n        pointBorderColor: '#fff',\r\n        pointHoverBackgroundColor: '#fff',\r\n        pointHoverBorderColor: 'rgba(179,181,198,1)',\r\n        data: [65, 59, 90, 81, 56, 55, 40],\r\n      },\r\n    ],\r\n  };\r\n\r\n  get randomData() {\r\n    return Math.round(Math.random() * 100);\r\n  }\r\n\r\n  ngOnInit(): void {\r\n    this.predictionService.getUserData().subscribe({\r\n      next: (userData) => {\r\n        this.singlePredictionHistory = userData.predictionHistory;\r\n        this.pendingFiles = userData.pendingFiles;\r\n        this.myFiles = userData.completedFiles;\r\n        this.filteredFiles = this.myFiles;\r\n        \r\n        // Set active CSV file if any exist\r\n        if (this.csvFiles.length > 0) {\r\n          this.activeCsvFile = this.csvFiles[0].id;\r\n        }\r\n        \r\n        // Set initial data for single prediction display\r\n        if (this.singlePredictionHistory.length > 0) {\r\n          this.lastSinglePrediction = { ...this.singlePredictionHistory[0] };\r\n          this.selectedHistoryItem = this.singlePredictionHistory[0];\r\n        }\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading user data:', error);\r\n        // Fallback to sample data if API fails\r\n        this.csvFiles = SAMPLE_CSV_FILES;\r\n        this.singlePredictionHistory = SAMPLE_PREDICTION_HISTORY;\r\n        this.pendingFiles = SAMPLE_PENDING_FILES;\r\n        this.myFiles = SAMPLE_MY_FILES;\r\n        this.filteredFiles = this.myFiles;\r\n        \r\n        if (this.singlePredictionHistory.length > 0) {\r\n          this.lastSinglePrediction = { ...this.singlePredictionHistory[0] };\r\n          this.selectedHistoryItem = this.singlePredictionHistory[0];\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  private generateFiveCategorySentiment(index: number): number[] {\r\n    let values: number[] = [0, 0, 0, 0, 0];\r\n\r\n    switch (index % 5) {\r\n      case 0: // Very positive\r\n        values = [5, 7, 13, 30, 45];\r\n        break;\r\n      case 1: // Very negative\r\n        values = [42, 28, 15, 10, 5];\r\n        break;\r\n      case 2: // Slightly positive\r\n        values = [8, 12, 20, 38, 22];\r\n        break;\r\n      case 3: // Slightly negative\r\n        values = [25, 35, 20, 15, 5];\r\n        break;\r\n      case 4: // Neutral\r\n        values = [12, 18, 40, 20, 10];\r\n        break;\r\n    }\r\n\r\n    return values;\r\n  }\r\n\r\n  showHistoryItemChart(prediction: any): void {\r\n    this.selectedHistoryItem = prediction;\r\n\r\n    // Update the current chart with this prediction's data\r\n    this.lastSinglePrediction = {\r\n      text: prediction.text,\r\n      result: prediction.result,\r\n      confidence: prediction.confidence,\r\n      categories: prediction.categories,\r\n      timestamp: prediction.timestamp,\r\n    };\r\n\r\n    // Clear the cache to force chart update\r\n    this._cachedChartData = null;\r\n  }\r\n\r\n  isSelectedHistoryItem(prediction: any): boolean {\r\n    return (\r\n      this.selectedHistoryItem &&\r\n      this.selectedHistoryItem.timestamp === prediction.timestamp\r\n    );\r\n  }\r\n\r\n  filterFiles(): void {\r\n    if (!this.fileSearchQuery) {\r\n      this.filteredFiles = this.myFiles;\r\n      return;\r\n    }\r\n\r\n    const query = this.fileSearchQuery.toLowerCase();\r\n    this.filteredFiles = this.myFiles.filter((file) =>\r\n      file.name.toLowerCase().includes(query)\r\n    );\r\n  }\r\n\r\n  clearFileSearch(): void {\r\n    this.fileSearchQuery = '';\r\n    this.filterFiles();\r\n  }\r\n\r\n  selectCsvFile(fileId: string): void {\r\n    this.activeCsvFile = fileId;\r\n    this.currentPage = 0;\r\n  }\r\n\r\n  // Method to get current active CSV file data\r\n  get currentCsvFile(): CsvFile | undefined {\r\n    return this.csvFiles.find((file) => file.id === this.activeCsvFile);\r\n  }\r\n\r\n  predictSingleText(): void {\r\n    const textValue = this.singlePredictionForm.get('textInput')?.value;\r\n    if (!textValue) return;\r\n    this.isProcessingSinglePrediction = true;\r\n\r\n    this.predictionService.predictText(textValue).subscribe({\r\n      next: (result) => {\r\n        // Transform the API response to our internal format\r\n        const categories = Object.entries(result.sentiment_scores)\r\n          .map(([name, value]) => ({\r\n            name: name === 'neutral' ? 'Neutral' : name, // Normalize 'neutral' to 'Neutral'\r\n            value: Number((value as number * 100).toFixed(2)) // Convert to percentage and round\r\n          }));\r\n\r\n        // Create prediction result\r\n        const prediction = {\r\n          text: textValue,\r\n          result: result.final_prediction,\r\n          confidence: Number((result.sentiment_scores[result.final_prediction] * 100).toFixed(2)),\r\n          categories: categories,\r\n          timestamp: new Date(),\r\n          rawResponse: result // Keep raw response for reference if needed\r\n        };\r\n\r\n        // Save prediction to history in the mock service\r\n        this.predictionService.savePredictionToHistory(prediction);\r\n\r\n        // Update last prediction and add to history\r\n        this.lastSinglePrediction = { ...prediction };\r\n        this.singlePredictionHistory.unshift({ ...prediction });\r\n\r\n        // Select the new prediction\r\n        this.selectedHistoryItem = this.singlePredictionHistory[0];\r\n        this.historyCurrentPage = 0;\r\n\r\n        // Clear the cached chart data to force an update\r\n        this._cachedChartData = null;\r\n\r\n        // Reset form and loading state\r\n        this.singlePredictionForm.reset();\r\n        this.isProcessingSinglePrediction = false;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error predicting text:', error);\r\n        this.isProcessingSinglePrediction = false;\r\n        // Handle error - perhaps show an error message to the user\r\n        alert('Failed to process prediction. Please try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  getHeaders(dataRow: any): string[] {\r\n    if (!dataRow) return [];\r\n    return Object.keys(dataRow);\r\n  }\r\n\r\n  /**\r\n   * Removes a CSV file from the visualization\r\n   * @param fileId The ID of the file to remove\r\n   * @param event The click event (to prevent it from triggering the tab selection)\r\n   */\r\n  deleteCsvFile(fileId: string, event: Event): void {\r\n    // Stop the event from propagating (to prevent tab selection)\r\n    // Stop event propagation to prevent tab selection\r\n    event.stopPropagation();\r\n\r\n    // Find and remove the file\r\n    const index = this.csvFiles.findIndex((file) => file.id === fileId);\r\n    if (index !== -1) {\r\n      this.csvFiles.splice(index, 1);\r\n\r\n      // If we deleted the active file, select another one\r\n      if (fileId === this.activeCsvFile && this.csvFiles.length > 0) {\r\n        this.activeCsvFile = this.csvFiles[0].id;\r\n      } else if (this.csvFiles.length === 0) {\r\n        this.activeCsvFile = '';\r\n      }\r\n    }\r\n  }\r\n\r\n  // Method for file selection\r\n  onFileSelected(event: Event): void {\r\n    const fileInput = event.target as HTMLInputElement;\r\n    const file = fileInput?.files?.[0];\r\n    fileInput.value = ''; // Reset input so same file can be uploaded again\r\n\r\n    if (file) {\r\n      this.fileUploadForm.patchValue({\r\n        fileName: file.name,\r\n        csvFile: file,\r\n      });\r\n    }\r\n  }\r\n\r\n  // Basic CSV parser (you might want to use a library for more complex CSVs)\r\n  parseCsvData(csv: string): any[] {\r\n    const lines = csv.split('\\n');\r\n    const headers = lines[0].split(',');\r\n    const result: any[] = [];\r\n\r\n    for (let i = 1; i < lines.length; i++) {\r\n      if (lines[i].trim() === '') continue;\r\n\r\n      const obj: any = {};\r\n      const currentLine = lines[i].split(',');\r\n\r\n      for (let j = 0; j < headers.length; j++) {\r\n        obj[headers[j].trim()] = currentLine[j]?.trim();\r\n      }\r\n\r\n      result.push(obj);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // Generate chart data from CSV\r\n  generateChartDataFromCsv(csvData: any[]): ChartData {\r\n    // Simplified example\r\n    const firstRow = csvData[0];\r\n    if (!firstRow) return { labels: [], datasets: [] };\r\n\r\n    const keys = Object.keys(firstRow);\r\n    const labels = keys.slice(1); // Assuming first column is label\r\n\r\n    return {\r\n      labels,\r\n      datasets: [\r\n        {\r\n          label: 'CSV Data',\r\n          backgroundColor: 'rgba(75,192,192,0.2)',\r\n          borderColor: 'rgba(75,192,192,1)',\r\n          pointBackgroundColor: 'rgba(75,192,192,1)',\r\n          pointBorderColor: '#fff',\r\n          pointHoverBackgroundColor: '#fff',\r\n          pointHoverBorderColor: 'rgba(75,192,192,1)',\r\n          data: csvData.map((row) => parseFloat(row[keys[1]])),\r\n        },\r\n      ],\r\n    };\r\n  }\r\n\r\n\r\n  predictCsvFile(): void {\r\n    const file = this.fileUploadForm.get('csvFile')?.value;\r\n\r\n    if (!file) {\r\n      alert('Please select a file first');\r\n      return;\r\n    }\r\n\r\n    // Upload file for prediction\r\n    this.predictionService.uploadCsvForPrediction(file).subscribe({\r\n      next: (response) => {\r\n        if (!response) {\r\n          // Handle null response\r\n          alert('Failed to upload file. Please try again.');\r\n          return;\r\n        }\r\n        \r\n        // Add to pending files\r\n        this.pendingFiles.push({\r\n          id: response.fileId,\r\n          name: response.name || file.name,\r\n          timestamp: new Date(response.timestamp) || new Date()\r\n        });\r\n\r\n        // Reset form\r\n        this.fileUploadForm.reset();\r\n\r\n        // Start polling for status updates\r\n        this.pollFileStatus(response.fileId);\r\n      },\r\n      error: (error) => {\r\n        console.error('Error uploading file:', error);\r\n        alert('Failed to upload file. Please try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  loadFileToVisualization(fileId: string): void {\r\n    // Check if file already exists in visualization tabs\r\n    const existingFileIndex = this.csvFiles.findIndex(file => file.id === fileId);\r\n    \r\n    if (existingFileIndex !== -1) {\r\n      // File already exists in tabs, just activate it\r\n      this.activeCsvFile = fileId;\r\n      return;\r\n    }\r\n    \r\n    // Otherwise, fetch file details from API\r\n    this.predictionService.getFileDetails(fileId).subscribe({\r\n      next: (fileDetails) => {\r\n        // Create chart data from the file details\r\n        const chartData = this.generateChartDataFromApiResponse(fileDetails);\r\n        \r\n        // Add to visualization tabs\r\n        const newFile: CsvFile = {\r\n          id: fileId,\r\n          name: fileDetails.name,\r\n          status: 'completed',\r\n          timestamp: new Date(fileDetails.timestamp),\r\n          isDefault: false,\r\n          data: fileDetails.data || [],\r\n          chartData: chartData\r\n        };\r\n        \r\n        this.csvFiles.push(newFile);\r\n        this.activeCsvFile = fileId;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading file details:', error);\r\n        alert('Failed to load file details. Please try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  // Chart data for single prediction\r\n  get singlePredictionChartData(): ChartData {\r\n    if (!this.lastSinglePrediction) return { datasets: [] };\r\n\r\n    // Return cached data if prediction hasn't changed\r\n    if (\r\n      this._cachedChartData &&\r\n      this._lastPredictionTimeStamp === this.lastSinglePrediction.timestamp\r\n    ) {\r\n      return this._cachedChartData;\r\n    }\r\n\r\n    // Generate new chart data\r\n    const chartData: ChartData = {\r\n      labels: this.lastSinglePrediction.categories.map((c) => c.name),\r\n      datasets: [\r\n        {\r\n          data: this.lastSinglePrediction.categories.map((c) => c.value),\r\n          backgroundColor: [\r\n            'rgba(255, 99, 132, 0.6)',\r\n            'rgba(54, 162, 235, 0.6)',\r\n            'rgba(255, 206, 86, 0.6)',\r\n          ],\r\n          borderWidth: 1,\r\n        },\r\n      ],\r\n    };\r\n\r\n    // Cache the data and timestamp\r\n    this._cachedChartData = chartData;\r\n    this._lastPredictionTimeStamp = this.lastSinglePrediction.timestamp;\r\n\r\n    return chartData;\r\n  }\r\n\r\n  getPaginatedData(\r\n    dataArray: any[],\r\n    currentPage: number,\r\n    pageSize: number\r\n  ): any[] {\r\n    if (!dataArray || !dataArray.length) return [];\r\n    const start = currentPage * pageSize;\r\n    const end = start + pageSize;\r\n    return dataArray.slice(start, end);\r\n  }\r\n\r\n  // Common method to get visible page numbers\r\n  getVisiblePageNumbers(\r\n    totalItems: number,\r\n    pageSize: number,\r\n    currentPage: number\r\n  ): number[] {\r\n    const totalPages = Math.ceil(totalItems / pageSize);\r\n    const pages: number[] = [];\r\n\r\n    if (totalPages <= 7) {\r\n      // Show all pages if 7 or fewer\r\n      for (let i = 0; i < totalPages; i++) {\r\n        pages.push(i);\r\n      }\r\n    } else {\r\n      // Show first, last, current, and pages around current\r\n      pages.push(0); // First page\r\n\r\n      if (currentPage > 2) {\r\n        pages.push(-1); // Ellipsis\r\n      }\r\n\r\n      // Pages around current\r\n      const start = Math.max(1, currentPage - 1);\r\n      const end = Math.min(totalPages - 2, currentPage + 1);\r\n\r\n      for (let i = start; i <= end; i++) {\r\n        pages.push(i);\r\n      }\r\n\r\n      if (currentPage < totalPages - 3) {\r\n        pages.push(-1); // Ellipsis\r\n      }\r\n\r\n      if (totalPages > 1) {\r\n        pages.push(totalPages - 1); // Last page\r\n      }\r\n    }\r\n\r\n    return pages;\r\n  }\r\n\r\n  // Common method to change page\r\n  changePage(page: number, target: 'bulk' | 'history'): void {\r\n    if (target === 'bulk') {\r\n      const totalPages = this.currentCsvFile\r\n        ? Math.ceil(this.currentCsvFile.data.length / this.pageSize)\r\n        : 0;\r\n\r\n      if (page >= 0 && page < totalPages) {\r\n        this.currentPage = page;\r\n      }\r\n    } else {\r\n      const totalPages = Math.ceil(\r\n        this.singlePredictionHistory.length / this.historyPageSize\r\n      );\r\n\r\n      if (page >= 0 && page < totalPages) {\r\n        this.historyCurrentPage = page;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Common method to handle page size changes\r\n  onPageSizeChange(target: 'bulk' | 'history'): void {\r\n    if (target === 'bulk') {\r\n      this.currentPage = 0;\r\n    } else {\r\n      this.historyCurrentPage = 0;\r\n    }\r\n  }\r\n\r\n  formatCategoriesForTooltip(categories: any[]): string {\r\n    if (!categories || !Array.isArray(categories)) return 'No categories';\r\n    \r\n    return categories\r\n      .map(cat => `${cat.name}: ${cat.value}%`)\r\n      .join('\\n');\r\n  }\r\n\r\n  // Helper method to get color for category\r\n  getCategoryColor(categoryName: string): string {\r\n    const colorMap: Record<string, string> = {\r\n      'Very Negative': 'rgba(220, 53, 69, 0.8)',\r\n      'Slightly Negative': 'rgba(255, 193, 7, 0.8)',\r\n      'Neutral': 'rgba(108, 117, 125, 0.8)',\r\n      'Slightly Positive': 'rgba(13, 202, 240, 0.8)',\r\n      'Very Positive': 'rgba(25, 135, 84, 0.8)'\r\n    };\r\n    \r\n    return colorMap[categoryName] || 'gray';\r\n  }\r\n\r\n  showCategoriesModal(categories: any[]): void {\r\n    this.selectedCategories = categories;\r\n    this.showCategoryModal = true;\r\n    \r\n    console.log('Categories:', categories);\r\n    setTimeout(() => {\r\n      this.showCategoryModal = false;\r\n    }, 3000);\r\n  }\r\n\r\n  pollFileStatus(fileId: string): void {\r\n    // Clear any existing subscription\r\n    if (this.statusCheckSubscription) {\r\n      this.statusCheckSubscription.unsubscribe();\r\n    }\r\n\r\n    // Set up initial polling variable\r\n    let completedOrError = false;\r\n\r\n    // Poll every 2 seconds\r\n    this.statusCheckSubscription = interval(2000).subscribe(() => {\r\n      // Don't check if we already know it's completed\r\n      if (completedOrError) return;\r\n\r\n      this.predictionService.checkFileStatus(fileId).subscribe({\r\n        next: (status) => {\r\n          if (status.status === 'completed') {\r\n            // File is now completed\r\n            completedOrError = true;\r\n            \r\n            // Remove from pending files\r\n            this.pendingFiles = this.pendingFiles.filter(file => file.id !== fileId);\r\n            \r\n            // Refresh the files list to get the new completed file\r\n            this.refreshFilesList();\r\n            \r\n            // Clean up the subscription\r\n            if (this.statusCheckSubscription) {\r\n              this.statusCheckSubscription.unsubscribe();\r\n              this.statusCheckSubscription = null;\r\n            }\r\n          } else if (status.status === 'error') {\r\n            // Handle error state\r\n            completedOrError = true;\r\n            this.pendingFiles = this.pendingFiles.filter(file => file.id !== fileId);\r\n            alert(`Processing of file failed: ${fileId}`);\r\n            \r\n            // Clean up the subscription\r\n            if (this.statusCheckSubscription) {\r\n              this.statusCheckSubscription.unsubscribe();\r\n              this.statusCheckSubscription = null;\r\n            }\r\n          }\r\n          // For 'pending' status, we just keep polling\r\n        },\r\n        error: (error) => {\r\n          console.error('Error checking file status:', error);\r\n          completedOrError = true; // Stop polling on error\r\n          \r\n          // Clean up the subscription\r\n          if (this.statusCheckSubscription) {\r\n            this.statusCheckSubscription.unsubscribe();\r\n            this.statusCheckSubscription = null;\r\n          }\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  refreshFilesList(): void {\r\n    this.predictionService.getFiles().subscribe({\r\n      next: (response) => {\r\n        // Update pending files\r\n        this.pendingFiles = response.pendingFiles.map(file => ({\r\n          id: file.id,\r\n          name: file.name,\r\n          timestamp: new Date(file.timestamp)\r\n        }));\r\n        \r\n        // Update completed files\r\n        this.myFiles = response.completedFiles.map(file => ({\r\n          id: file.id,\r\n          name: file.name,\r\n          status: 'completed',\r\n          timestamp: new Date(file.timestamp),\r\n          isDefault: false,\r\n          data: [], // Empty initially, will be loaded when file is selected\r\n          chartData: undefined // Will be generated when data is loaded\r\n        }));\r\n        \r\n        // Update filtered files\r\n        this.filterFiles();\r\n        \r\n        // Trigger change detection to update the UI\r\n        this.cdr.detectChanges();\r\n      },\r\n      error: (error) => {\r\n        console.error('Error fetching files:', error);\r\n        this.cdr.detectChanges();\r\n      }\r\n    });\r\n  }\r\n\r\n  generateChartDataFromApiResponse(fileDetails: any): ChartData {\r\n    // Assuming the API returns data with sentiment categories and counts\r\n    const sentimentCounts: Record<string, number> = {\r\n      'Very Positive': 0, \r\n      'Slightly Positive': 0, \r\n      'Neutral': 0, \r\n      'Slightly Negative': 0, \r\n      'Very Negative': 0\r\n    };\r\n    \r\n    // Count prediction categories\r\n    if (fileDetails.data && Array.isArray(fileDetails.data)) {\r\n      fileDetails.data.forEach((item: any) => {\r\n        const prediction = item.Prediction;\r\n        // Check if prediction exists and is a key in sentimentCounts\r\n        if (prediction && Object.prototype.hasOwnProperty.call(sentimentCounts, prediction)) {\r\n          sentimentCounts[prediction as keyof typeof sentimentCounts]++;\r\n        }\r\n      });\r\n    }\r\n    \r\n    return {\r\n      labels: Object.keys(sentimentCounts),\r\n      datasets: [{\r\n        label: 'Sentiment Distribution',\r\n        backgroundColor: [\r\n          'rgba(25, 135, 84, 0.8)',      // Very Positive - green\r\n          'rgba(13, 202, 240, 0.8)',     // Slightly Positive - info blue\r\n          'rgba(108, 117, 125, 0.8)',    // Neutral - gray\r\n          'rgba(255, 193, 7, 0.8)',      // Slightly Negative - amber\r\n          'rgba(220, 53, 69, 0.8)',      // Very Negative - red\r\n        ],\r\n        borderColor: 'rgba(179,181,198,1)',\r\n        data: Object.values(sentimentCounts)\r\n      }]\r\n    };\r\n  }\r\n\r\n\r\n  ngOnDestroy(): void {\r\n    if (this.statusCheckSubscription) {\r\n      this.statusCheckSubscription.unsubscribe();\r\n    }\r\n  }\r\n\r\n}\r\n"
        }
    ]
}