{
    "sourceFile": "Frontend/src/app/views/dashboard/prediction.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 15,
            "patches": [
                {
                    "date": 1747822237634,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1747838190897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,11 +18,124 @@\n })\r\n export class PredictionService {\r\n   private apiUrl = environment.apiUrl || 'https://api.yourdomain.com';\r\n   private useMockData = true; // Set to false to use real API\r\n+  private authToken: string | null = null;\r\n \r\n-  constructor(private http: HttpClient) { }\r\n+  constructor(private http: HttpClient) {\r\n+    // Check for saved token in local storage\r\n+    this.authToken = localStorage.getItem('authToken');\r\n+  }\r\n \r\n+  // Authentication methods\r\n+  login(username: string, password: string): Observable<any> {\r\n+    if (this.useMockData) {\r\n+      return this.mockLogin(username, password);\r\n+    }\r\n+    \r\n+    const endpoint = `${this.apiUrl}/auth/login`;\r\n+    return this.http.post<any>(endpoint, { username, password }).pipe(\r\n+      tap(response => {\r\n+        if (response && response.token) {\r\n+          this.authToken = response.token;\r\n+          localStorage.setItem('authToken', this.authToken);\r\n+        }\r\n+      }),\r\n+      catchError(this.handleError)\r\n+    );\r\n+  }\r\n+\r\n+  register(email: string, username: string, password: string): Observable<any> {\r\n+    if (this.useMockData) {\r\n+      return this.mockRegister(email, username, password);\r\n+    }\r\n+    \r\n+    const endpoint = `${this.apiUrl}/auth/register`;\r\n+    return this.http.post<any>(endpoint, { email, username, password }).pipe(\r\n+      catchError(this.handleError)\r\n+    );\r\n+  }\r\n+\r\n+  logout(): void {\r\n+    // Clear authentication data\r\n+    this.authToken = null;\r\n+    localStorage.removeItem('authToken');\r\n+  }\r\n+\r\n+  isLoggedIn(): boolean {\r\n+    return !!this.authToken;\r\n+  }\r\n+\r\n+  // Mock authentication methods for development\r\n+  private mockLogin(username: string, password: string): Observable<any> {\r\n+    // Valid test credentials\r\n+    const validUsers = [\r\n+      { username: 'testuser', password: 'password123', email: 'test@example.com' },\r\n+      { username: 'admin', password: 'admin123', email: 'admin@example.com' }\r\n+    ];\r\n+\r\n+    const user = validUsers.find(u => u.username === username && u.password === password);\r\n+    \r\n+    if (user) {\r\n+      const mockToken = `mock-jwt-token-${Math.random().toString(36).substring(2, 15)}`;\r\n+      this.authToken = mockToken;\r\n+      localStorage.setItem('authToken', mockToken);\r\n+      \r\n+      return of({\r\n+        token: mockToken,\r\n+        user: { \r\n+          username: user.username, \r\n+          email: user.email \r\n+        }\r\n+      }).pipe(delay(800)); // Simulate network delay\r\n+    } else {\r\n+      return throwError(() => new Error('Invalid username or password')).pipe(delay(800));\r\n+    }\r\n+  }\r\n+\r\n+  private mockRegister(email: string, username: string, password: string): Observable<any> {\r\n+    // Check if username already exists in our mock data\r\n+    const validUsers = [\r\n+      { username: 'testuser', password: 'password123', email: 'test@example.com' },\r\n+      { username: 'admin', password: 'admin123', email: 'admin@example.com' }\r\n+    ];\r\n+\r\n+    if (validUsers.some(u => u.username === username)) {\r\n+      return throwError(() => new Error('Username already exists')).pipe(delay(800));\r\n+    }\r\n+\r\n+    if (validUsers.some(u => u.email === email)) {\r\n+      return throwError(() => new Error('Email already registered')).pipe(delay(800));\r\n+    }\r\n+\r\n+    // Registration successful\r\n+    return of({\r\n+      success: true,\r\n+      message: 'Registration successful'\r\n+    }).pipe(delay(800)); // Simulate network delay\r\n+  }\r\n+\r\n+  // Error handling\r\n+  private handleError(error: any) {\r\n+    let errorMessage = '';\r\n+    if (error.error instanceof ErrorEvent) {\r\n+      // Client-side error\r\n+      errorMessage = `Error: ${error.error.message}`;\r\n+    } else {\r\n+      // Server-side error\r\n+      errorMessage = `Error Code: ${error.status}\\nMessage: ${error.message}`;\r\n+    }\r\n+    return throwError(() => new Error(errorMessage));\r\n+  }\r\n+\r\n+  // Get headers with auth token\r\n+  private getAuthHeaders(): HttpHeaders {\r\n+    return new HttpHeaders({\r\n+      'Content-Type': 'application/json',\r\n+      'Authorization': `Bearer ${this.authToken}`\r\n+    });\r\n+  }\r\n+\r\n   /**\r\n    * Predict sentiment from a single text input\r\n    * @param text Text to analyze\r\n    * @returns Observable with prediction result\r\n@@ -33,9 +146,9 @@\n     }\r\n     \r\n     const endpoint = `${this.apiUrl}/predict`;\r\n     const payload = { text };\r\n-    return this.http.post<any>(endpoint, payload);\r\n+    return this.http.post<any>(endpoint, payload, { headers: this.getAuthHeaders() });\r\n   }\r\n \r\n   /**\r\n    * Upload and process a CSV file for bulk prediction\r\n@@ -49,9 +162,9 @@\n     \r\n     const endpoint = `${this.apiUrl}/upload`;\r\n     const formData = new FormData();\r\n     formData.append('file', file);\r\n-    return this.http.post<any>(endpoint, formData);\r\n+    return this.http.post<any>(endpoint, formData, { headers: this.getAuthHeaders() });\r\n   }\r\n \r\n   /**\r\n    * Get list of all files (both completed and pending)\r\n@@ -62,9 +175,9 @@\n       return mockGetFiles();\r\n     }\r\n     \r\n     const endpoint = `${this.apiUrl}/files`;\r\n-    return this.http.get<any>(endpoint);\r\n+    return this.http.get<any>(endpoint, { headers: this.getAuthHeaders() });\r\n   }\r\n \r\n   /**\r\n    * Get detailed results for a specific file\r\n@@ -76,9 +189,9 @@\n       return mockGetFileDetails(fileId);\r\n     }\r\n     \r\n     const endpoint = `${this.apiUrl}/files/${fileId}`;\r\n-    return this.http.get<any>(endpoint);\r\n+    return this.http.get<any>(endpoint, { headers: this.getAuthHeaders() });\r\n   }\r\n \r\n   /**\r\n    * Check status of a pending file\r\n@@ -94,9 +207,9 @@\n       return mockCheckFileStatus(fileId);\r\n     }\r\n     \r\n     const endpoint = `${this.apiUrl}/files/${fileId}/status`;\r\n-    return this.http.get<any>(endpoint);\r\n+    return this.http.get<any>(endpoint, { headers: this.getAuthHeaders() });\r\n   }\r\n \r\n   /**\r\n    * Get user data including prediction history and files\r\n@@ -107,9 +220,9 @@\n       return mockGetUserData();\r\n     }\r\n     \r\n     const endpoint = `${this.apiUrl}/user/data`;\r\n-    return this.http.get<any>(endpoint);\r\n+    return this.http.get<any>(endpoint, { headers: this.getAuthHeaders() });\r\n   }\r\n \r\n   /**\r\n    * Helper method to add prediction to history (for mock data)\r\n"
                },
                {
                    "date": 1747838446735,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,9 +36,9 @@\n     return this.http.post<any>(endpoint, { username, password }).pipe(\r\n       tap(response => {\r\n         if (response && response.token) {\r\n           this.authToken = response.token;\r\n-          localStorage.setItem('authToken', this.authToken);\r\n+          localStorage.setItem('authToken', response.token); // Using direct value instead of this.authToken\r\n         }\r\n       }),\r\n       catchError(this.handleError)\r\n     );\r\n@@ -77,9 +77,9 @@\n     \r\n     if (user) {\r\n       const mockToken = `mock-jwt-token-${Math.random().toString(36).substring(2, 15)}`;\r\n       this.authToken = mockToken;\r\n-      localStorage.setItem('authToken', mockToken);\r\n+      localStorage.setItem('authToken', mockToken); // This is fine because mockToken is always string\r\n       \r\n       return of({\r\n         token: mockToken,\r\n         user: { \r\n@@ -128,11 +128,12 @@\n   }\r\n \r\n   // Get headers with auth token\r\n   private getAuthHeaders(): HttpHeaders {\r\n+    // Ensure we never pass null to the Authorization header\r\n     return new HttpHeaders({\r\n       'Content-Type': 'application/json',\r\n-      'Authorization': `Bearer ${this.authToken}`\r\n+      'Authorization': `Bearer ${this.authToken || ''}` // Use empty string as fallback\r\n     });\r\n   }\r\n \r\n   /**\r\n"
                },
                {
                    "date": 1747838482957,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,10 +77,9 @@\n     \r\n     if (user) {\r\n       const mockToken = `mock-jwt-token-${Math.random().toString(36).substring(2, 15)}`;\r\n       this.authToken = mockToken;\r\n-      localStorage.setItem('authToken', mockToken); // This is fine because mockToken is always string\r\n-      \r\n+localStorage.setItem('authToken', response.token);      \r\n       return of({\r\n         token: mockToken,\r\n         user: { \r\n           username: user.username, \r\n"
                },
                {
                    "date": 1747838570107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,9 +64,8 @@\n   isLoggedIn(): boolean {\r\n     return !!this.authToken;\r\n   }\r\n \r\n-  // Mock authentication methods for development\r\n   private mockLogin(username: string, password: string): Observable<any> {\r\n     // Valid test credentials\r\n     const validUsers = [\r\n       { username: 'testuser', password: 'password123', email: 'test@example.com' },\r\n@@ -77,9 +76,9 @@\n     \r\n     if (user) {\r\n       const mockToken = `mock-jwt-token-${Math.random().toString(36).substring(2, 15)}`;\r\n       this.authToken = mockToken;\r\n-localStorage.setItem('authToken', response.token);      \r\n+      localStorage.setItem('authToken', response.token);      \r\n       return of({\r\n         token: mockToken,\r\n         user: { \r\n           username: user.username, \r\n"
                },
                {
                    "date": 1747838664521,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,10 @@\n     \r\n     if (user) {\r\n       const mockToken = `mock-jwt-token-${Math.random().toString(36).substring(2, 15)}`;\r\n       this.authToken = mockToken;\r\n-      localStorage.setItem('authToken', response.token);      \r\n+      localStorage.setItem('authToken', mockToken); // Fixed: using mockToken instead of response.token\r\n+    \r\n       return of({\r\n         token: mockToken,\r\n         user: { \r\n           username: user.username, \r\n"
                },
                {
                    "date": 1747912041915,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n @Injectable({\r\n   providedIn: 'root'\r\n })\r\n export class PredictionService {\r\n-  private apiUrl = environment.apiUrl || 'https://api.yourdomain.com';\r\n+  private apiUrl = environment.apiUrl;\r\n   private useMockData = true; // Set to false to use real API\r\n   private authToken: string | null = null;\r\n \r\n   constructor(private http: HttpClient) {\r\n"
                },
                {
                    "date": 1747912048806,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,9 @@\n   providedIn: 'root'\r\n })\r\n export class PredictionService {\r\n   private apiUrl = environment.apiUrl;\r\n-  private useMockData = true; // Set to false to use real API\r\n+  private useMockData = false;\r\n   private authToken: string | null = null;\r\n \r\n   constructor(private http: HttpClient) {\r\n     // Check for saved token in local storage\r\n"
                },
                {
                    "date": 1747912073989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n   login(username: string, password: string): Observable<any> {\r\n     if (this.useMockData) {\r\n       return this.mockLogin(username, password);\r\n     }\r\n-    \r\n+\r\n     const endpoint = `${this.apiUrl}/auth/login`;\r\n     return this.http.post<any>(endpoint, { username, password }).pipe(\r\n       tap(response => {\r\n         if (response && response.token) {\r\n"
                },
                {
                    "date": 1747912162474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -230,7 +230,6 @@\n   savePredictionToHistory(prediction: any): void {\r\n     if (this.useMockData) {\r\n       addPredictionToHistory(prediction);\r\n     }\r\n-    // If using real API, the history would be saved server-side\r\n   }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748182568579,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,23 +2,15 @@\n import { HttpClient, HttpHeaders } from '@angular/common/http';\r\n import { Observable, of, throwError } from 'rxjs';\r\n import { catchError, delay, map, tap } from 'rxjs/operators';\r\n import { environment } from '../../environment/environment';\r\n-import {\r\n-  mockPredictText,\r\n-  mockUploadCsvFile,\r\n-  mockGetFiles,\r\n-  mockGetFileDetails,\r\n-  mockCheckFileStatus,\r\n-  mockGetUserData,\r\n-  addPredictionToHistory\r\n-} from './datafiles';\r\n+import { addPredictionToHistory, mockCheckFileStatus, mockGetFileDetails, mockGetFiles, mockGetUserData, mockPredictText, mockUploadCsvFile } from './datafiles';\r\n \r\n @Injectable({\r\n   providedIn: 'root'\r\n })\r\n export class PredictionService {\r\n-  private apiUrl = environment.apiUrl;\r\n+  private apiUrl = environment.apiUrl || 'https://api.yourdomain.com';\r\n   private useMockData = false;\r\n   private authToken: string | null = null;\r\n \r\n   constructor(private http: HttpClient) {\r\n@@ -30,9 +22,9 @@\n   login(username: string, password: string): Observable<any> {\r\n     if (this.useMockData) {\r\n       return this.mockLogin(username, password);\r\n     }\r\n-\r\n+    \r\n     const endpoint = `${this.apiUrl}/auth/login`;\r\n     return this.http.post<any>(endpoint, { username, password }).pipe(\r\n       tap(response => {\r\n         if (response && response.token) {\r\n@@ -230,6 +222,7 @@\n   savePredictionToHistory(prediction: any): void {\r\n     if (this.useMockData) {\r\n       addPredictionToHistory(prediction);\r\n     }\r\n+    // If using real API, the history would be saved server-side\r\n   }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748182644110,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n   providedIn: 'root'\r\n })\r\n export class PredictionService {\r\n   private apiUrl = environment.apiUrl || 'https://api.yourdomain.com';\r\n-  private useMockData = false;\r\n+  private useMockData = true;\r\n   private authToken: string | null = null;\r\n \r\n   constructor(private http: HttpClient) {\r\n     // Check for saved token in local storage\r\n"
                },
                {
                    "date": 1748183789294,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,11 @@\n @Injectable({\r\n   providedIn: 'root'\r\n })\r\n export class PredictionService {\r\n+  downloadFile(fileId: string) {\r\n+    throw new Error('Method not implemented.');\r\n+  }\r\n   private apiUrl = environment.apiUrl || 'https://api.yourdomain.com';\r\n   private useMockData = true;\r\n   private authToken: string | null = null;\r\n \r\n"
                },
                {
                    "date": 1748183800531,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,20 @@\n   providedIn: 'root'\r\n })\r\n export class PredictionService {\r\n   downloadFile(fileId: string) {\r\n-    throw new Error('Method not implemented.');\r\n+    if (this.useMockData) {\r\n+      return of({ success: true, message: 'File downloaded successfully' }).pipe(delay(800));\r\n+    }\r\n+\r\n+    const endpoint = `${this.apiUrl}/files/${fileId}/download`;\r\n+    return this.http.get(endpoint, { responseType: 'blob', headers: this.getAuthHeaders() }).pipe(\r\n+      tap(response => {\r\n+        // Handle successful download\r\n+        console.log('File downloaded successfully:', response);\r\n+      }),\r\n+      catchError(this.handleError)\r\n+    );\r\n   }\r\n   private apiUrl = environment.apiUrl || 'https://api.yourdomain.com';\r\n   private useMockData = true;\r\n   private authToken: string | null = null;\r\n"
                },
                {
                    "date": 1748183822857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,9 @@\n @Injectable({\r\n   providedIn: 'root'\r\n })\r\n export class PredictionService {\r\n-  downloadFile(fileId: string): {\r\n+  downloadFile(fileId: string): Observable<any> {\r\n     if (this.useMockData) {\r\n       return of({ success: true, message: 'File downloaded successfully' }).pipe(delay(800));\r\n     }\r\n \r\n"
                },
                {
                    "date": 1748187410146,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,9 +62,8 @@\n     const validUsers = [\r\n       { username: 'testuser', password: 'password123', email: 'test@example.com' },\r\n       { username: 'admin', password: 'admin123', email: 'admin@example.com' }\r\n     ];\r\n-    \r\n \r\n     const user = validUsers.find(u => u.username === username && u.password === password);\r\n     \r\n     if (user) {\r\n"
                }
            ],
            "date": 1747822237634,
            "name": "Commit-0",
            "content": "import { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\r\nimport { Observable, of, throwError } from 'rxjs';\r\nimport { catchError, delay, map, tap } from 'rxjs/operators';\r\nimport { environment } from '../../environment/environment';\r\nimport {\r\n  mockPredictText,\r\n  mockUploadCsvFile,\r\n  mockGetFiles,\r\n  mockGetFileDetails,\r\n  mockCheckFileStatus,\r\n  mockGetUserData,\r\n  addPredictionToHistory\r\n} from './datafiles';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class PredictionService {\r\n  private apiUrl = environment.apiUrl || 'https://api.yourdomain.com';\r\n  private useMockData = true; // Set to false to use real API\r\n\r\n  constructor(private http: HttpClient) { }\r\n\r\n  /**\r\n   * Predict sentiment from a single text input\r\n   * @param text Text to analyze\r\n   * @returns Observable with prediction result\r\n   */\r\n  predictText(text: string): Observable<any> {\r\n    if (this.useMockData) {\r\n      return mockPredictText(text);\r\n    }\r\n    \r\n    const endpoint = `${this.apiUrl}/predict`;\r\n    const payload = { text };\r\n    return this.http.post<any>(endpoint, payload);\r\n  }\r\n\r\n  /**\r\n   * Upload and process a CSV file for bulk prediction\r\n   * @param file CSV file to process\r\n   * @returns Observable with file ID for tracking\r\n   */\r\n  uploadCsvForPrediction(file: File): Observable<{ fileId: string, name: string, timestamp: Date }> {\r\n    if (this.useMockData) {\r\n      return mockUploadCsvFile(file);\r\n    }\r\n    \r\n    const endpoint = `${this.apiUrl}/upload`;\r\n    const formData = new FormData();\r\n    formData.append('file', file);\r\n    return this.http.post<any>(endpoint, formData);\r\n  }\r\n\r\n  /**\r\n   * Get list of all files (both completed and pending)\r\n   * @returns Observable with file lists\r\n   */\r\n  getFiles(): Observable<{ pendingFiles: any[], completedFiles: any[] }> {\r\n    if (this.useMockData) {\r\n      return mockGetFiles();\r\n    }\r\n    \r\n    const endpoint = `${this.apiUrl}/files`;\r\n    return this.http.get<any>(endpoint);\r\n  }\r\n\r\n  /**\r\n   * Get detailed results for a specific file\r\n   * @param fileId ID of the file to retrieve\r\n   * @returns Observable with file data and results\r\n   */\r\n  getFileDetails(fileId: string): Observable<any> {\r\n    if (this.useMockData) {\r\n      return mockGetFileDetails(fileId);\r\n    }\r\n    \r\n    const endpoint = `${this.apiUrl}/files/${fileId}`;\r\n    return this.http.get<any>(endpoint);\r\n  }\r\n\r\n  /**\r\n   * Check status of a pending file\r\n   * @param fileId ID of the file to check\r\n   * @returns Observable with current status\r\n   */\r\n  checkFileStatus(fileId: string): Observable<{ \r\n    status: string; \r\n    progress?: number;\r\n    message?: string; // Add this optional property\r\n  }> {\r\n    if (this.useMockData) {\r\n      return mockCheckFileStatus(fileId);\r\n    }\r\n    \r\n    const endpoint = `${this.apiUrl}/files/${fileId}/status`;\r\n    return this.http.get<any>(endpoint);\r\n  }\r\n\r\n  /**\r\n   * Get user data including prediction history and files\r\n   * @returns Observable with user data\r\n   */\r\n  getUserData(): Observable<{ predictionHistory: any[], pendingFiles: any[], completedFiles: any[] }> {\r\n    if (this.useMockData) {\r\n      return mockGetUserData();\r\n    }\r\n    \r\n    const endpoint = `${this.apiUrl}/user/data`;\r\n    return this.http.get<any>(endpoint);\r\n  }\r\n\r\n  /**\r\n   * Helper method to add prediction to history (for mock data)\r\n   */\r\n  savePredictionToHistory(prediction: any): void {\r\n    if (this.useMockData) {\r\n      addPredictionToHistory(prediction);\r\n    }\r\n    // If using real API, the history would be saved server-side\r\n  }\r\n}"
        }
    ]
}