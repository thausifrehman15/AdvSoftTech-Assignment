{
    "sourceFile": "Frontend/src/app/views/dashboard/prediction_prod.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1748182606672,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1748182606672,
            "name": "Commit-0",
            "content": "import { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\r\nimport { Observable, of, throwError } from 'rxjs';\r\nimport { catchError, delay, map, tap } from 'rxjs/operators';\r\nimport { environment } from '../../environment/environment';\r\nimport { LoginResponse, LoginRequest, RegisterResponse, RegisterRequest, PredictionResponse, PredictionRequest, FileUploadResponse, FileListResponse, FileDetailResponse, FileStatusResponse, UserDataResponse } from './prediction.interface';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class PredictionService {\r\n  private apiUrl = environment.apiUrl;\r\n  private authToken: string | null = null;\r\n  private username: string | null = null;\r\n  \r\n  private useMockData = true;\r\n\r\n  constructor(private http: HttpClient) {\r\n    this.authToken = localStorage.getItem('authToken');\r\n    this.username = localStorage.getItem('username');\r\n  }\r\n\r\n  // Helper method to get auth headers\r\n  private getHeaders(): HttpHeaders {\r\n    let headers = new HttpHeaders({\r\n      'Content-Type': 'application/json'\r\n    });\r\n    \r\n    if (this.authToken) {\r\n      headers = headers.set('Authorization', `Bearer ${this.authToken}`);\r\n    }\r\n    \r\n    return headers;\r\n  }\r\n\r\n  login(username: string, password: string): Observable<LoginResponse> {\r\n    if (this.useMockData) {\r\n      // Mock successful login\r\n      return of({\r\n        token: 'mock-token-' + Math.random().toString(36).substring(2),\r\n        user: {\r\n          id: '1',\r\n          username: username,\r\n          email: username + '@example.com'\r\n        },\r\n        message: 'Login successful'\r\n      }).pipe(\r\n        delay(800), // Simulate network delay\r\n        tap(response => {\r\n          this.authToken = response.token;\r\n          this.username = username;\r\n          localStorage.setItem('authToken', response.token);\r\n          localStorage.setItem('username', username);\r\n        })\r\n      );\r\n    }\r\n    \r\n    // Real API call\r\n    const endpoint = `${this.apiUrl}/auth/login`;\r\n    const request: LoginRequest = { username, password };\r\n    \r\n    return this.http.post<LoginResponse>(endpoint, request).pipe(\r\n      tap(response => {\r\n        if (response && response.token) {\r\n          this.authToken = response.token;\r\n          this.username = username;\r\n          localStorage.setItem('authToken', response.token);\r\n          localStorage.setItem('username', username); \r\n        }\r\n      }),\r\n      catchError(this.handleError)\r\n    );\r\n  }\r\n\r\n  register(email: string, username: string, password: string): Observable<RegisterResponse> {\r\n    if (this.useMockData) {\r\n      // Mock successful registration\r\n      return of({\r\n        success: true,\r\n        message: 'Registration successful',\r\n        user: {\r\n          id: '2',\r\n          username: username,\r\n          email: email\r\n        }\r\n      }).pipe(delay(800)); // Simulate network delay\r\n    }\r\n    \r\n    // Real API call\r\n    const endpoint = `${this.apiUrl}/auth/register`;\r\n    const request: RegisterRequest = { email, username, password };\r\n    \r\n    return this.http.post<RegisterResponse>(endpoint, request).pipe(\r\n      catchError(this.handleError)\r\n    );\r\n  }\r\n\r\n  logout(): void {\r\n    this.authToken = null;\r\n    this.username = null;\r\n    localStorage.removeItem('authToken');\r\n    localStorage.removeItem('username');\r\n  }\r\n\r\n  isLoggedIn(): boolean {\r\n    return !!this.authToken;\r\n  }\r\n\r\n  getCurrentUsername(): string | null {\r\n    return this.username;\r\n  }\r\n\r\n  predictText(text: string): Observable<PredictionResponse> {\r\n    // Real API call\r\n    const endpoint = `${this.apiUrl}/predict`;\r\n    const payload: PredictionRequest = { text };\r\n    return this.http.post<PredictionResponse>(endpoint, payload, { headers: this.getHeaders() });\r\n  }\r\n\r\n  // File upload\r\n  uploadCsvForPrediction(file: File): Observable<FileUploadResponse> {    \r\n    // Real API call\r\n    const endpoint = `${this.apiUrl}/upload`;\r\n    const formData = new FormData();\r\n    formData.append('file', file);\r\n    return this.http.post<FileUploadResponse>(endpoint, formData, { headers: this.getHeaders() });\r\n  }\r\n\r\n  // Get file list\r\n  getFiles(): Observable<FileListResponse> {\r\n    // Real API call\r\n    const endpoint = `${this.apiUrl}/files`;\r\n    return this.http.get<FileListResponse>(endpoint, { headers: this.getHeaders() });\r\n  }\r\n\r\n  // Get file details\r\n  getFileDetails(fileId: string): Observable<FileDetailResponse> {\r\n    // Real API call\r\n    const endpoint = `${this.apiUrl}/files/${fileId}`;\r\n    return this.http.get<FileDetailResponse>(endpoint, { headers: this.getHeaders() });\r\n  }\r\n\r\n  // Check file status\r\n  checkFileStatus(fileId: string): Observable<FileStatusResponse> {\r\n    // Real API call\r\n    const endpoint = `${this.apiUrl}/files/${fileId}/status`;\r\n    return this.http.get<FileStatusResponse>(endpoint, { headers: this.getHeaders() });\r\n  }\r\n\r\n  // Get user data\r\n  getUserData(): Observable<UserDataResponse> {\r\n    // Real API call\r\n    const endpoint = `${this.apiUrl}/user/data`;\r\n    return this.http.get<UserDataResponse>(endpoint, { headers: this.getHeaders() });\r\n  }\r\n\r\n  /**\r\n   * Save a prediction to the user's history\r\n   * @param prediction The prediction object to save\r\n   */\r\n  savePredictionToHistory(prediction: any): void {\r\n    // For a real API, you would send this to the server\r\n    // Since we're using mock data, we'll update local storage or call the mock function\r\n    \r\n    if (this.authToken) {\r\n      // Convert the timestamp to string format if it's a Date object\r\n      const predictionToSave = {\r\n        ...prediction,\r\n        timestamp: prediction.timestamp instanceof Date \r\n          ? prediction.timestamp.toISOString() \r\n          : prediction.timestamp\r\n      };\r\n      \r\n      // You could also store in localStorage for persistence between page refreshes\r\n      try {\r\n        const savedPredictions = JSON.parse(localStorage.getItem('predictionHistory') || '[]');\r\n        savedPredictions.unshift(predictionToSave);\r\n        localStorage.setItem('predictionHistory', JSON.stringify(savedPredictions.slice(0, 50))); // Keep last 50\r\n      } catch (e) {\r\n        console.error('Failed to save prediction to localStorage:', e);\r\n      }\r\n    }\r\n  }\r\n\r\n  private handleError(error: any) {\r\n    let errorMessage = '';\r\n    if (error.error instanceof ErrorEvent) {\r\n      // Client-side error\r\n      errorMessage = `Error: ${error.error.message}`;\r\n    } else {\r\n      // Server-side error\r\n      errorMessage = `Error Code: ${error.status}\\nMessage: ${error.message}`;\r\n    }\r\n    return throwError(() => new Error(errorMessage));\r\n  }\r\n}"
        }
    ]
}